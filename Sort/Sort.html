<html>
  <head>
    <meta charset="UTF-8">
    <title>排序算法的比较</title>
    <link rel="stylesheet" href="../common.css">
  </head>
  <body>
    <main>
      <h1>排序算法的比较</h1>
      <h2>数据结构课程设计作业</h2>
      <ol>
      <section>
        <li><h3>简介</h3></li>
        <p>本程序实现了一个各种排序效率比较系统，并提供了一个简单的可以展示其功能的命令行界面。</p>
        <p>本系统使用C++语言写成，可以在任何支持C++14标准的编译器上编译通过。</p>
      </section>
      <section>
        <li><h3>功能</h3></li>
        <p>本程序基于命令行，用户输入生成的随机数数量，然后程序利用不同的排序方法对这批随机数进行排序，并输出所需时间。</p>
        <p>大致的形式像这样：</p>
        <blockquote>
            ##		排序算法比较		## <br>
            ##					## <br>
            请输入要产生的随机数的个数：50000 <br>
            经过43ms，50000个随机数生成完毕 <br>
            插入排序耗费了432ms <br>
            冒泡排序耗费了1437ms <br>
            选择排序耗费了776ms <br>
            快速排序耗费了3ms <br>
            堆排序耗费了2056ms <br>
            希尔排序耗费了6ms <br>
            折半插入排序耗费了236ms <br>
            基数排序耗费了7ms <br>
            归并排序耗费了7ms <br>
            标准库sort耗费了12ms <br>
            标准库stable_sort耗费了3ms
        </blockquote>
        <p>程序对于同样的一批数据，输出各种排序算法的所需时间。</p>
      </section>
      <section>
        <li><h3>实现</h3></li>
        <p>这里的实现用到了九种排序方法，分别是：</p>
        <ul>
          <li>插入排序</li>
          <li>冒泡排序</li>
          <li>选择排序</li>
          <li>快速排序</li>
          <li>堆排序</li>
          <li>希尔排序</li>
          <li>折半插入排序</li>
          <li>基数排序</li>
          <li>归并排序</li>
        </ul>
        <h4>插入排序</h4>
        <p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
        <p>插入排序是一种稳定的排序，非常适合在数据量较小时进行排序。</p>
        <h4>冒泡排序</h4>
        <p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢「浮」到数列的顶端，形似液体气泡上浮。</p>
        <p>冒泡排序属于最容易实现的排序算法之一，但是效率上非常低。</p>
        <h4>选择排序</h4>
        <p>选择排序它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
        <p>选择排序的交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，所以当数组元素数量较小时，选择排序比冒泡排序快。</p>
        <h4>快速排序</h4>
        <p>快速排序使用分治法策略来把一个序列分为两个子序列，然后分别排序。即先确定一个主元，将比主元小的元素放到其左边，比主元大的元素放到其右边，然后对两个子序列递归地执行这个操作。</p>
        <p>平均情况下，快速排序的时间复杂度是<kbd>O(nlogn)</kbd>，但是在大部分情况下，原地快速排序的情况对缓存十分友好，所以效率非常高。</p>
        <h4>堆排序</h4>
        <p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于它的父节点。</p>
        <p>在这里的程序中，我们用到的堆排序属于原地堆排序，时间复杂度为<kbd>O(nlogn)</kbd>.</p>
        <h4>希尔排序</h4>
        <p>希尔排序是插入排序的一种更高效的改进版本，属于非稳定排序算法。希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了。</p>
        <p>理论上而言，<kbd>1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905</kbd>这个序列比较适合作为步长。但是就实现方面而言，这里我们使用长度的一半作为初始步长，之后逐渐减半。</p>
        <h4>折半插入排序</h4>
        <p>折半插入排序是插入排序的另一个改进版本，改进的地方主要在于这个前移的过程。不是一个一个地比较，而是采用二分法，快速确定要插入的位置，减少了比较的次数，提高了效率。</p>
        <h4>基数排序</h4>
        <p>基数排序利用数的位数进行排序，将整数按位数切割成不同的数字，然后按每个位数分别比较，最后实现有序。为了实现方便，这里我们按照0或1来区分两个桶。</p>
        <p>要注意的是，我们这里判断了整数是否为带符号的，如果是，那最左边会被区别对待。</p>
        <p>除了基数排序，其他的排序都可以用于整数之外的任意类型数据的排序。</p>
        <h4>归并排序</h4>
        <p>归并排序，是创建在归并操作上的一种有效的排序算法。每次操作都需要两个新的空间，最后将两个空间放在一起。归并排序中最重要的就是归并操作。</p>
        <h4>随机数生成</h4>
        <p>本程序的随机数生成使用了C++11新带来的随机数生成器<code>random_device</code>和分布工具，可以创建具有高随机的随机数序列。</p>
        <h4>时间测算</h4>
        <p>时间测算也用到了C++11新的头文件<kbd>chrono</kbd>，时间可以精确到毫秒。</p>
      </section>
      <section>
        <li><h3>API</h3></li>
        <p>排序API充分利用了C++模版的优势，实现了泛型化。还利用到了traits等高级模版技术，保证程序的通用性。</p>
        <pre><code>
// 冒泡排序
template&lt;typename InputIt&gt;
void BubbleSort(InputIt start, InputIt end);

// 选择排序
template&lt;typename InputIt&gt;
void SelectionSort(InputIt start, InputIt end);

// 快速排序
template&lt;typename InputIt&gt;
void QuicksSort(InputIt start, InputIt end);

// 插入排序
template&lt;typename InputIt&gt;
void InsertSort(InputIt start, InputIt end);

// 希尔排序
template&lt;typename InputIt&gt;
void ShellSort(InputIt start, InputIt end);

// 折半插入排序
template&lt;typename InputIt&gt;
void HalfInsertSort(InputIt start, InputIt end);

// 归并排序 
template&lt;typename InputIt&gt;
void MergeSort(InputIt start, InputIt end);

// 堆排序
template&lt;typename InputIt&gt;
void HeapSort(InputIt start, InputIt end);

// 基数排序
template&lt;typename InputIt&gt;
void RadixSort(InputIt start, InputIt end);
        </code></pre>
      </section>
      </ol>
    </main>
    <footer>
      2016, 邱超凡
    </footer>
  </body>
</html>